# PLOT YOUTUBE THUMBNIALS TO A SPACIALISED GEXF GRAPH
#
# HEAVILY BASED ON MINTZ'S IMAGE NETWORK PLOTTER
# DANIEL LOIOLA 2020
#
# VAPORWAVE IS DEAD ETC


#! /usr/bin/env python3
import svgwrite as svg
import xml.etree.ElementTree as et
import os, configparser, argparse, sys, platform, traceback
from PIL import Image

# Added to donwload images from YouTube
import requests
import shutil

# settings dict
settings = {}

def cleanQuotes(path):
    if (path.startswith('\'') and path.endswith('\'')) or (path.startswith('\"') and path.endswith('\"')):
       return path[1:-1]
    else:
        return path

def parsearg():
    parser = argparse.ArgumentParser(description='Plot images in image-label networks generated by Memespector script')
    parser.add_argument('--configfile',
                        metavar="CONFIG_PATH",
                        nargs=1,
                        default='config.txt',
                        help='Receives string for path to config file. Use this in case you wish to override the default config file.'
                        )
    return parser.parse_args()

def parseconfigfile(path="config.txt"):
    global settings
    configfile = configparser.ConfigParser()
    try:
        configfile.read(path)
    except Exception:
        raise

    try:
        settings['input']       = cleanQuotes(configfile.get('Input', 'InputGraph'))
        settings['copyresized'] = configfile.getboolean('Output', 'CopyImagesResized')
        settings['outimgdir']   = configfile.get('Output', 'ResizedImageFolderName')
        settings['resizew']     = configfile.getint('Output', 'ResizeMaxWidth')
        settings['resizeh']     = configfile.getint('Output', 'ResizeMaxHeight')
        settings['dispw']       = configfile.getint('Output', 'ImageMaxDispWidth')
        settings['disph']       = configfile.getint('Output', 'ImageMaxDispHeight')
        settings['restrpage']   = configfile.getboolean('Output', 'RestricttoPage')
        settings['outw']        = configfile.getint('Output', 'OutputWidth')
        settings['outh']        = configfile.getint('Output', 'OutputHeight')
        settings['download']    = configfile.getboolean('Output', 'DownloadMode')
        settings['folder']      = cleanQuotes(configfile.get('Output', 'DownloadFolder'))
    except Exception as exc:
        print(exc)
        sys.exit("\n**ERROR**\nCould not parse at least one of the settings from the config file. Please verify its contents carefully.")

def loadSettings():
    args = parsearg()
    parseconfigfile(args.configfile)

def main():
    ''' Checks the input file type and calls the plotter function '''


    # load data from the settings file
    print("\n-------------------------\nImage Network Plotter\n-------------------------")
    loadSettings()

    # ------------------------------------------
    # Get the file names, extensions and call function
    # -------------------------------------------

    file_ext = os.path.splitext(settings['input'])[1]
    print("Extension >>> " + file_ext)

    # output file name
    outputfilename = os.path.join(os.path.dirname(settings['input']), "visual_" + os.path.basename(settings['input']).split(".")[0] + ".svg")


    # if the file type is not supported show an error message
    if file_ext == '.svg':
        svg_plotter(settings['input'], outputfilename)
    if file_ext == '.gexf':
        gexf_plot(outputfilename)





def svg_plotter(file, output_file):
    '''plots the video thumbnails on a svg file'''

    # Needed to find the substrings
    # necessario para encontrar substrings
    import re

    # list to store the lines from the input file
    # lista que armazena as linhas do arquivo de entrada
    lista_de_linhas = []

    # open original file
    # abre o arquivo original
    arquivo = open(file, 'r', encoding='utf8')

    # iterate over the file and remove the \n leavong one tag per line
    # itera pelo arquivo original e remove o \n para deixar uma tag por linha
    for linha in arquivo:

        # remove identation
        # remove identacao
        linha_sem_espaco = linha.lstrip()
        linha_final = ''

        # remove the \n from the lines inside the tags and append to list
        # remove o \n de dentro das tags e anexa a lista
        if linha_sem_espaco[-2] != '>':
            linha_final = linha_sem_espaco.replace('\n',' ')
            lista_de_linhas.append(linha_final)

        # if the line is closing the tag, only append to the list
        # quando nao ha o \n apenas anexa a linah a lista
        else:
            linha_final = linha_sem_espaco
            lista_de_linhas.append(linha_final)

    # Close the file
    # fecha o arquivo
    arquivo.close()

    # open the output file
    # abre o arquivo de saida
    f = open(output_file, 'w')

    # create a counter; if the value is 1 or 2 it will stop the
    #loop from adding data tha's not from a node to the final svg file
    #
    # cria um contador; se o valor for 1 ou 2 impede o loop de adicionar
    # dados que nao sao de nodes no arquivo final
    counter = 0

    for item in lista_de_linhas:

        # look only for the nodes
        # encontra os nos
        if counter == 0:
            if item[0:7] == '<circle':

                r =  re.findall(r'r=".+?"',item)[0][3:-1]
                cx = float(re.findall(r'cx=".+?"',item)[0][4:-1]) - float(r)*1.5
                counter = 1

        if counter == 1:
            if item[23:27] == 'cy="':

                cy = float(re.findall(r'cy=".+?"',item)[0][4:-1]) - float(r)*1.5
                id_class = re.findall(r'class=".+?"',item)[0][10:-1]
                counter = 2

        if counter == 2:
            if item[0:6] == 'stroke':

                # if we re on the last line of the tag, then also add the img tag
                # then resets counter for the next tag and skip to the next iteration
                # se for a ultima linha da tag, tambem adiciona a imagem
                # e reseta o contador para a proxima tag e pula para a proxima iteracao




                ##############################################
                # DOWNLOAD MODE
                ##############################################
                if settings['download'] == True:

                    imgfile = "https://i.ytimg.com/vi/" + id_class + "/hqdefault.jpg?sqp=-oaymwEZCOADEI4CSFXyq4qpAwsIARUAAIhCGAFwAQ"
                    response = requests.get(imgfile, stream=True)

                    with open(settings['folder'] + str(id_class) + '.jpg', 'wb') as out_file:
                        shutil.copyfileobj(response.raw, out_file)

                    f.write(item)
                    f.write(f'<a id="{id_class}" target="_blank" xlink:href="https://youtube.com/watch?v={id_class}"><image height="{float(r)*3}" width="{float(r)*3}" x="{cx}" xlink:href="{settings["folder"]}/{id_class}.jpg" y="{cy}"/></a>')
                    print(f"Added image {id_class}")

                else:
                    f.write(item)
                    f.write(f'<a id="{id_class}" target="_blank" xlink:href="https://youtube.com/watch?v={id_class}"><image height="{float(r)*3}" width="{float(r)*3}" x="{cx}" xlink:href="https://i.ytimg.com/vi/{id_class}/hqdefault.jpg?sqp=-oaymwEZCOADEI4CSFXyq4qpAwsIARUAAIhCGAFwAQ" y="{cy}"/></a>')
                    print(f"Added image {id_class}")


                counter = 0
                continue

        # finally writes the line
        # por ultimo, escreve a linha no arquivo
        f.write(item)

    # close everything and finishes
    # fecha o arquivo e termina
    f.close()


def gexf_plot(outputfilename):



    #outputfilename = os.path.join(os.path.dirname(settings['input']), "visual_" + os.path.basename(settings['input']).split(".")[0] + ".svg")
    imgresizedim = settings['resizew'], settings['resizeh']
    imgdrawdim = settings['dispw'], settings['disph']

    print("Input file:", settings['input'])
    ingexf = et.parse(settings['input'])

    try:

        # ------------------------------------------
        # Create output dir
        #-------------------------------------------

        if settings['copyresized']:
            if os.path.isabs(settings['outimgdir']):
                outimgdir = settings['outimgdir']
            else:
                outimgdir = os.path.join(os.path.dirname(settings['input']), settings['outimgdir'])
            if not os.path.exists(outimgdir):
                os.makedirs(outimgdir)

        # ------------------------------------------
        # Parse GEXF and generate SVG
        #-------------------------------------------

        try:

            inroot = ingexf.getroot()
            ns = {'gexf' : "http://www.gexf.net/1.3" }
            viz = {'viz' : "http://www.gexf.net/1.3/viz"}

        except Exception as exc:
            print(exc)
            print("**ERROR**\nCould not parse GEXF.")

        typeAttId = -1
        linkAttId = -1
        fileAttId = -1

        graph = inroot.find("gexf:graph", ns)
        if not graph:
            sys.exit("\n**ERROR**\nCould not parse graph file.\n")

        attributes = graph.find(".gexf:attributes",ns)

        for att in attributes:
            if att.get('title') == 'type':
                typeAttId = att.get('id')
            elif att.get('title') == 'link':
                linkAttId = att.get('id')
            elif att.get('title') == 'file':
                fileAttId = att.get('id')

        nodes = graph.find("gexf:nodes", ns)

        # Find graph bounding box and count images
        numnodes = 0
        numimages = 0

        minx = 0
        maxx = 0
        miny = 0
        maxy = 0

        for node in nodes:
            numnodes += 1
            typeAtt = node.find("gexf:attvalues/gexf:attvalue[@for=\'" + str(typeAttId) +"\']",ns)

            numimages += 1
            try:
                inimgx = float(node.find("viz:position", viz).get('x'))
                inimgy = float(node.find("viz:position", viz).get('y'))
            except AttributeError:
                sys.exit("\n\n**ERROR**\nGraph has not been spatialized. Could not find position data for the nodes\nOpen it in Gephi, apply spatialization algorithm and export to another file.\n")
            except Exception:
                raise
            if inimgx < minx:
                minx = inimgx
            if inimgx > maxx:
                maxx = inimgx
            if inimgy < miny:
                miny = inimgy
            if inimgy > maxy:
                maxy = inimgy

        print("Graph contains", numnodes, "nodes.")
        print("Plotting", numimages, "images.\n")
        print("Minimum X:", minx)
        print("Maximum X:", maxx)
        print("Minimum Y:", miny)
        print("Maximum Y:", maxy)

        # --------
        # Configure output conversion

        inw = maxx - minx
        inh = maxy - miny

        if (inw/inh) >= (settings['outw']/settings['outh']):
            # match width
            outfactor = settings['outw'] / inw
        else:
            # match height
            outfactor = settings['outh'] / inh

        outw = inw * outfactor
        outh = inh * outfactor
        outx = (settings['outw'] - outw)/2
        outy = (settings['outh'] - outh)/2

        # --------
        # Draw output

        outsvg = svg.Drawing(outputfilename, (settings['outw'], settings['outh']), debug=True)
        curimg = 1

        for node in nodes:


            print("\n\nDrawing image", curimg, "in", numimages)
            curimg += 1

            innodex = (float(node.find("viz:position", viz).get('x'))-minx)/inw
            innodey = (float(node.find("viz:position", viz).get('y'))-miny)/inh

            if settings['restrpage']:
                outnodex = (innodex * outw) + outx
                outnodey = (innodey * outh) + outy
            else:
                outnodex = innodex
                outnodey = innodey

            nodeid = node.get('id')


            imgfile = "https://i.ytimg.com/vi/" + nodeid + "/hqdefault.jpg?sqp=-oaymwEZCOADEI4CSFXyq4qpAwsIARUAAIhCGAFwAQ"
            linkUrl = "https://youtube.com/watch?v=" + nodeid


            print("\tImage file:", imgfile)


            response = requests.get(imgfile, stream=True)

            if settings['download'] == True:

                with open(settings['folder'] + str(nodeid) + '.jpg', 'wb') as out_file:
                    shutil.copyfileobj(response.raw, out_file)
                infile = settings['folder'] + str(nodeid) + '.jpg'
            else:
                with open('img.jpg', 'wb') as out_file:
                    shutil.copyfileobj(response.raw, out_file)
                infile = 'img.jpg'

            try:
                curimage = Image.open(infile)
            except Exception:
                print("\t**ATTENTION** Image could not be loaded.\n")
                continue

            if settings['copyresized']:
                imgfp = imgfile
                print("\tResizing image...")
                try:
                    curimage.thumbnail(imgresizedim, Image.ANTIALIAS)
                    curimage.save(imgfp)
                except Exception as exc:
                    print("\t**ATTENTION** Problem resizing image.\n")
                    print(exc)
                    continue
            else:
                if settings['download'] == False:
                    imgfp = imgfile
                if settings['download'] == True:
                    imgfp = infile

            print("\tPlotting image...\n")

            link = outsvg.add(outsvg.a(linkUrl,id=nodeid))
            image = link.add(outsvg.image(imgfp, insert=(outnodex, outnodey), size=imgdrawdim))

            # get rid of the request response
            del response


        outsvg.save(pretty=True)

    # If the user interrupts the script or an error occurs
    except KeyboardInterrupt:
        if outsvg:
            outsvg.save(pretty=True)
        print("\n\n**Script interrupted by user**\n\n")
    except Exception:
        traceback.print_exc(file=sys.stdout)
    sys.exit(0)



if __name__ == "__main__":
    main()
